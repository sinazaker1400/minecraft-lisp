(in-package #:cl-opengl-examples/core)

(defun make-gear (inner-radius outer-radius width n-teeth tooth-depth)
  (declare (single-float inner-radius outer-radius width tooth-depth)
           (fixnum n-teeth))
  (format t "make gear ~s~%"
          (list :inner-radius :inner-radius :outer-radius outer-radius
                :width width :n-teeth n-teeth :tooth-depth tooth-depth))
  (let ((r0 inner-radius)
        (r1 (- outer-radius (/ tooth-depth 2.0)))
        (r2 (+ outer-radius (/ tooth-depth 2.0)))
        (da (/ (* 2.0 +pif+) n-teeth 4.0))
        (vh (make-hash-table :test 'equalp))
        (verts (make-array 0 :adjustable t :fill-pointer 0
                             :element-type 'single-float))
        (indices (make-array 0 :adjustable t :fill-pointer 0
                               :element-type '(unsigned-byte 16)))
        (p1 nil)
        (p2 nil)
        (p3 nil)
        (model nil)
        (mode nil)
        (normal nil))
    (labels ((idx (v n)
               (let ((k (list v n)))
                 (or (gethash k vh)
                     (let ((i (/ (fill-pointer verts) 6)))
                       (loop for i across (concatenate 'vector v n)
                             do (vector-push-extend i verts))
                       (setf (gethash k vh) i)))))
             (normal (x y z)
               (setf normal (sb-cga:normalize (vec x y z))))
             (start-primitive (new-mode)
               (setf p1 nil p2 nil p3 nil mode new-mode))
             (shade-model (new-model)
               (setf model new-model))
             (tri (a b c)
               (vector-push-extend a indices)
               (vector-push-extend b indices)
               (vector-push-extend c indices))
             (vertex (x y z)
               ;; fixme: implement shade-model :flat
               (let* ((v (vec x y z))
                      (i (idx v normal)))
                 (ecase mode
                   (:quad-strip
                    (when (and p1 p2 p3)
                      (tri p1 p2 p3)
                      (tri p2 i p3))
                    (shiftf p1 p2 p3 i))
                   (:quads
                    (cond
                      ((and p1 p2 p3)
                       (tri p1 p2 p3)
                       (tri p1 p3 i)
                       (setf p1 nil p2 nil p3 nil))
                      (t
                       (shiftf p1 p2 p3 i))))))))
      (shade-model :flat)
      (normal 0 0 1)
      ;; Draw front face.
      (start-primitive :quad-strip)
      (dotimes (i (1+ n-teeth))
        (let ((angle (/ (* i 2.0 +pif+) n-teeth)))
          (vertex (* r0 (cos angle)) (* r0 (sin angle)) (* width 0.5))
          (vertex (* r1 (cos angle)) (* r1 (sin angle)) (* width 0.5))
          (vertex (* r0 (cos angle)) (* r0 (sin angle)) (* width 0.5))
          (vertex (* r1 (cos (+ angle (* 3 da))))
                  (* r1 (sin (+ angle (* 3 da))))
                  (* width 0.5))))
      ;; Draw front sides of teeth.
      (start-primitive :quads)
      (dotimes (i n-teeth)
        (let ((angle (/ (* i 2.0 +pif+) n-teeth)))
          (vertex (* r1 (cos angle)) (* r1 (sin angle)) (* width 0.5))
          (vertex (* r2 (cos (+ angle da))) (* r2 (sin (+ angle da)))
                  (* width 0.5))
          (vertex (* r2 (cos (+ angle (* 2 da))))
                  (* r2 (sin (+ angle (* 2 da))))
                  (* width 0.5))
          (vertex (* r1 (cos (+ angle (* 3 da))))
                  (* r1 (sin (+ angle (* 3 da))))
                  (* width 0.5))))
      (normal 0 0 -1)
      ;; Draw back face.
      (start-primitive :quad-strip)
      (dotimes (i (1+ n-teeth))
        (let ((angle (/ (* i 2.0 +pif+) n-teeth)))
          (vertex (* r1 (cos angle)) (* r1 (sin angle)) (* width -0.5))
          (vertex (* r0 (cos angle)) (* r0 (sin angle)) (* width -0.5))
          (vertex (* r1 (cos (+ angle (* 3 da))))
                  (* r1 (sin (+ angle (* 3 da))))
                  (* width -0.5))
          (vertex (* r0 (cos angle)) (* r0 (sin angle)) (* width -0.5))))
      ;; Draw back sides of teeth.
      (start-primitive :quads)
      (dotimes (i n-teeth)
        (let ((angle (/ (* i 2.0 +pif+) n-teeth)))
          (vertex (* r1 (cos (+ angle (* 3 da))))
                  (* r1 (sin (+ angle (* 3 da))))
                  (* (- width) 0.5))
          (vertex (* r2 (cos (+ angle (* 2 da))))
                  (* r2 (sin (+ angle (* 2 da))))
                  (* (- width) 0.5))
          (vertex (* r2 (cos (+ angle da))) (* r2 (sin (+ angle da)))
                  (* (- width) 0.5))
          (vertex (* r1 (cos angle)) (* r1 (sin angle)) (* (- width) 0.5))))
      ;; Draw outward faces of teeth.
      (start-primitive :quad-strip)
      (dotimes (i n-teeth)
        (let ((angle (/ (* i 2.0 +pif+) n-teeth)))
          (vertex (* r1 (cos angle)) (* r1 (sin angle)) (* width 0.5))
          (vertex (* r1 (cos angle)) (* r1 (sin angle)) (* (- width) 0.5))
          (let* ((u (- (* r2 (cos (+ angle da))) (* r1 (cos angle))))
                 (v (- (* r2 (sin (+ angle da))) (* r1 (sin angle))))
                 (len (sqrt (+ (* u u) (* v v)))))
            (setq u (/ u len))
            (setq v (/ v len))
            (normal v (- u) 0.0)
            (vertex (* r2 (cos (+ angle da))) (* r2 (sin (+ angle da)))
                    (* width 0.5))
            (vertex (* r2 (cos (+ angle da))) (* r2 (sin (+ angle da)))
                    (* (- width) 0.5))
            (normal (cos angle) (sin angle) 0.0)
            (vertex (* r2 (cos (+ angle (* 2 da))))
                    (* r2 (sin (+ angle (* 2 da))))
                    (* width 0.5))
            (vertex (* r2 (cos (+ angle (* 2 da))))
                    (* r2 (sin (+ angle (* 2 da))))
                    (* (- width) 0.5))
            (setq u (- (* r1 (cos (+ angle (* 3 da))))
                       (* r2 (cos (+ angle (* 2 da))))))
            (setq v (- (* r1 (sin (+ angle (* 3 da))))
                       (* r2 (sin (+ angle (* 2 da))))))
            (normal v (- u) 0.0)
            (vertex (* r1 (cos (+ angle (* 3 da))))
                    (* r1 (sin (+ angle (* 3 da))))
                    (* width 0.5))
            (vertex (* r1 (cos (+ angle (* 3 da))))
                    (* r1 (sin (+ angle (* 3 da))))
                    (* (- width) 0.5))
            (normal (cos angle) (sin angle) 0.0))))
      (vertex (* r1 (cos 0)) (* r1 (sin 0)) (* width 0.5))
      (vertex (* r1 (cos 0)) (* r1 (sin 0)) (* (- width) 0.5))
      ;; Draw inside radius cylinder.
      (shade-model :smooth)
      (start-primitive :quad-strip)
      (dotimes (i (1+ n-teeth))
        (let ((angle (/ (* i 2.0 +pif+) n-teeth)))
          (normal (- (cos angle)) (- (sin angle)) 0.0)
          (vertex (* r0 (cos angle)) (* r0 (sin angle)) (* (- width) 0.5))
          (vertex (* r0 (cos angle)) (* r0 (sin angle)) (* width 0.5))))
      (list (coerce verts '(simple-array single-float 1))
            (coerce indices '(simple-array (unsigned-byte 16) 1))))))

(defclass gears (core-example)
  ((view-rot-x :accessor view-rot-x :initform 20.0)
   (view-rot-y :accessor view-rot-y :initform 30.0)
   (view-rot-z :accessor view-rot-z :initform 0.0)
   (angle :accessor angle :initform 0.0)
   (count :accessor frame-count :initform 1)
   (t0 :accessor t0 :initform 0)))

(defmethod resume ((g gears))
  ;; reset any global state assumed by drawing code
  (gl:bind-framebuffer :framebuffer 0)
  (gl:bind-texture :texture-2d 0)
  (gl:disable :blend)
  (gl:enable :depth-test :cull-face)
  (gl:blend-func :src-alpha :one-minus-src-alpha)
  (gl:viewport 0 0 (width g) (height g)))

(defmethod init-gl ((g gears))
  (add-vao g :gear1 (make-gear 1.0 4.0 1.0 20 0.7) *vertex-format/lit*)
  (add-vao g :gear2 (make-gear 0.5 2.0 2.0 10 0.7) *vertex-format/lit*)
  (add-vao g :gear3 (make-gear 1.3 2.0 0.5 10 0.7) *vertex-format/lit*)
  (add-program g :lit :vertex *vertex/lit* :fragment *fragment/lit* :verbose t)
  (with-program (g :lit)
    (setf (projection g) (sb-cga:identity-matrix))
    (gl:uniform-matrix-4fv (uniform-location :projectionmatrix)
                           (projection g)
                           nil)
    (let* ((view (translate 0 0 -40))
           ;; lightPos is in eye space (and is directional)
           (lpos (sb-cga:transform-direction (vec 5 5 10) view)))
      (setf (view g) view)
      (gl:uniform-matrix-4fv (uniform-location :viewmatrix)
                             view nil)
      (gl:uniformf (uniform-location :light0pos)
                   (aref lpos 0) (aref lpos 1) (aref lpos 2) 0.0))
    (gl:uniform-matrix-4fv (uniform-location :modelMatrix)
                           (sb-cga:identity-matrix)
                           nil)
    ;; gl defaults
    (gl:uniformf (uniform-location :sceneAmbient) 0.2 0.2 0.2)
    (gl:uniformf (uniform-location :light0Ambient) 0.0 0.0 0.0)
    (gl:uniformf (uniform-location :light0Diffuse) 1.0 1.0 1.0)
    (gl:uniformf (uniform-location :light0Specular) 1.0 1.0 1.0)
    (gl:uniformf (uniform-location :light0SpotDirection) 0.0 0.0 1.0)
    (gl:uniformf (uniform-location :light0SpotExponent) 0.0)
    (gl:uniformf (uniform-location :light0SpotCutoff) 180.0)
    (gl:uniformf (uniform-location :light0Attenuation) 1 0 0))
  (resume g))

(defmethod reshape :after ((g gears) w h)
  (let ((h (/ h w)))
    (setf (projection g) (frustum -1 1 (- h) h 5 60))
    (with-program (g :lit)
      (gl:uniform-matrix-4fv (uniform-location :projectionmatrix)
                             (projection g)
                             nil))))

(defmethod key ((g gears) key)
  ;; return NIL if we didn't process key, these all return a number so
  ;; using that instead of explicit T return
  (case key
    ((#\w :w :up :key-up) (incf (view-rot-x g) 5.0))
    ((#\s :s :down :key-down) (decf (view-rot-x g) 5.0))
    ((#\a :a :left :key-left) (incf (view-rot-y g) 5.0))
    ((#\d :d :right :key-right) (decf (view-rot-y g) 5.0))
    ((#\q :q :page-up) (incf (view-rot-z g) 5.0))
    ((#\e :e :page-down) (decf (view-rot-z g) 5.0))))

(defmethod draw ((g gears) now)
  (with-program (g :lit)
    ;; update angle (degrees/sec)
    (incf-mod-360 (angle g) (* 72.0 (dt g)))
    (labels ((draw-gear (n mv)
               (gl:uniform-matrix-4fv (uniform-location :modelMatrix) mv nil)
               (gl:uniform-matrix-3fv (uniform-location :normalMatrix)
                                      (normal-matrix3 mv) nil)
               (draw-vao g n)))
      (let* ((model (sb-cga:matrix* (rotate* (view-rot-x g) 1 0 0)
                                    (rotate* (view-rot-y g) 0 1 0)
                                    (rotate* (view-rot-z g) 0 0 1)))
             (angle (angle g)))
        ;;(gl:clear-color (* 0.2 (abs (sin (sf now)))) 0 0 1.0)
        (gl:clear-color 0 0 0 1.0)
        (gl:clear :color-buffer :depth-buffer)

        ;; gear 1 = red
        (gl:vertex-attrib 2 0.8 0.1 0 1.0)
        (draw-gear :gear1 (sb-cga:matrix* model
                                          (translate -3 -2 0)
                                          (rotate* angle 0 0 1)))

        ;; gear 2 = green
        (gl:vertex-attrib 2 0.0 0.8 0.2 1.0)
        (draw-gear :gear2 (sb-cga:matrix* model
                                          (translate 3.1 -2 0)
                                          (rotate* (- (* -2 angle) 9) 0 0 1)))

        ;; gear 3 = blue
        (gl:vertex-attrib 2 0.2 0.2 1.0 1.0)
        (draw-gear :gear3 (sb-cga:matrix* model
                                          (translate -3.1 4.2 0)
                                          (rotate* (- (* -2 angle) 25) 0 0 1)))
        ;; Calculating frame rate
        (incf (frame-count g))
        (let ((seconds (- now (t0 g))))
          (when (>= seconds 5)
            (let* ((fps (/ (frame-count g) seconds)))
              (format *terminal-io* "~D frames in ~3,1F seconds = ~6,3F FPS~%"
                      (frame-count g) seconds fps))
            (setf (t0 g) now)
            (setf (frame-count g) 0)))))))
